# 다양한 코드 문법 활용 실습 파트 코드
## 마빗으로 이것 저것 만들기!
* 샘플코드_01
```
```

* 샘플코드_02
```
```

* 샘플코드_03
```
```

* 샘플코드_04
```
```

* 샘플코드_05
```
```

* 샘플코드_06: 스탑워치 코드
```
from microbit import *
import time

# 스탑워치 시작 시간
start_time = 0
# 스탑워치 동작 여부
running = False

while True:
    if button_a.was_pressed():
        if running:
            running = False
        else:
            running = True
            start_time = time.ticks_ms()  # 현재 시간을 밀리초로 저장
    elif button_b.was_pressed():
        running = False

    if running:
        current_time = time.ticks_diff(time.ticks_ms(), start_time)  # 경과 시간 계산
        seconds = current_time // 1000  # 밀리초를 초로 변환
        display.show(str(seconds))
        sleep(1000)

    if not running:
        display.clear()

```


* 샘플코드_07: z축 가속도를 읽어오는 코드
```
from microbit import *

def map(value, fromMin, fromMax, toMin, toMax):
    fromRange = fromMax - fromMin
    toRange = toMax - toMin
    valueScaled = float(value - fromMin) / float(fromRange)
    return toMin + (valueScaled * toRange)

while True:
    # 가속도 센서로 Z축 가속도를 읽어옵니다.
    z_acceleration = accelerometer.get_z() 
    z_acceleration_trans=map(z_acceleration, 0, 1023, 0, 98)/10
    z_acceleration_trans=round(z_acceleration_trans, 2)
    print(z_acceleration_trans)
    sleep(1000)
"""
#마이크로비트에는 3축 가속도 센서가 기본적으로 내장되어 있습니다.

마이크로비트 가속도 센서의 측정 범위는 –2 g부터 2 g까지입니다.
예를 들어, 마이크로비트의 LED면이 위로 가도록 위치한 경우, 지구의 중력가속도는 z축 방향의 반대 방향을 향하기 때문에 다음과 같이 측정됩니다.

x축 = 0
y축 = 0
z축 = -1023 (국제단위계 m/2^2)으로 환산
"""
```

* 샘플코드_08: 좌우 기울기를 이용, 내려오는 벽 피하기 게임(참고: https://microbit-micropython.readthedocs.io/)
```
# Simple Slalom by Larry Hastings, September 2015
#
# This program has been placed into the public domain.

import microbit as m
import random

p = m.display.show

min_x = -1024
max_x = 1024
range_x = max_x - min_x

wall_min_speed = 400
player_min_speed = 200

wall_max_speed = 100
player_max_speed = 50

speed_max = 12


while True:

    i = m.Image('00000:'*5)
    s = i.set_pixel

    player_x = 2

    wall_y = -1
    hole = 0

    score = 0
    handled_this_wall = False

    wall_speed = wall_min_speed
    player_speed = player_min_speed

    wall_next = 0
    player_next = 0

    while True:
        t = m.running_time()
        player_update = t >= player_next
        wall_update = t >= wall_next
        if not (player_update or wall_update):
            next_event = min(wall_next, player_next)
            delta = next_event - t
            m.sleep(delta)
            continue

        if wall_update:
            # calculate new speeds
            speed = min(score, speed_max)
            wall_speed = wall_min_speed + int((wall_max_speed - wall_min_speed) * speed / speed_max)
            player_speed = player_min_speed + int((player_max_speed - player_min_speed) * speed / speed_max)

            wall_next = t + wall_speed
            if wall_y < 5:
                # erase old wall
                use_wall_y = max(wall_y, 0)
                for wall_x in range(5):
                    if wall_x != hole:
                        s(wall_x, use_wall_y, 0)

        wall_reached_player = (wall_y == 4)
        if player_update:
            player_next = t + player_speed
            # find new x coord
            x = m.accelerometer.get_x()
            x = min(max(min_x, x), max_x)
            # print("x accel", x)
            s(player_x, 4, 0) # turn off old pixel
            x = ((x - min_x) / range_x) * 5
            x = min(max(0, x), 4)
            x = int(x + 0.5)
            # print("have", position, "want", x)

            if not handled_this_wall:
                if player_x < x:
                    player_x += 1
                elif player_x > x:
                    player_x -= 1
            # print("new", position)
            # print()

        if wall_update:
            # update wall position
            wall_y += 1
            if wall_y == 7:
                wall_y = -1
                hole = random.randrange(5)
                handled_this_wall = False

            if wall_y < 5:
                # draw new wall
                use_wall_y = max(wall_y, 0)
                for wall_x in range(5):
                    if wall_x != hole:
                        s(wall_x, use_wall_y, 6)

        if wall_reached_player and not handled_this_wall:
            handled_this_wall = True
            if (player_x != hole):
                # collision! game over!
                break
            score += 1

        if player_update:
            s(player_x, 4, 9) # turn on new pixel

        p(i)

    p(i.SAD)
    m.sleep(1000)
    m.display.scroll("Score:" + str(score))

    while True:
        if (m.button_a.is_pressed() and m.button_a.is_pressed()):
            break
        m.sleep(100)
```
