# 모듈과 라이브러리 파트 코드
## 배우기 샘플코드
### 클래스 이해 및 실습
* 샘플코드_01-1
  - 클래스(class) 기본
```
from microbit import *

class LED:
    def __init__(self):
        pass

    def on(self):
        display.show(Image.HEART) # LED를 켜는 메소드

    def off(self):
        display.clear() # LED를 끄는 메소드

# 클래스 사용
led = LED()
while True:
    led.on() #LED().on()
    sleep(1000)
    led.off() #LED().off()
    sleep(1000)
```
* 샘플코드_01-2
  - 파라미터(parameter)를 사용하는 클래스
```
from microbit import *

class LED:
    def __init__(self, interval):
        self.interval = interval # 점멸 간격을 설정하는 인스턴스 변수

    def blink(self):
        display.show(Image.HEART)
        sleep(self.interval)
        display.clear()
        sleep(self.interval)

# 클래스 사용
led = LED(500) # 500ms 간격으로 점멸
while True:
    led.blink()
```
### 모듈 이해 및 실습
* 샘플코드_02-base_display.py 파일
```
# base_features.py 파일은 부모 클래스 파일(모듈)
from microbit import display, Image

class DisplayObject:
    def show(self):
        """디스플레이 객체가 출력될 때 기본 동작을 정의합니다."""
        display.show(Image.HAPPY)

class ButtonHandler:
    def __init__(self, button):
        self.button = button

    def is_pressed(self):
        """버튼이 눌렸는지 확인하는 메소드입니다."""
        return self.button.is_pressed()
```
* 샘플코드_02-custom_display.py 파일
```
# advanced_features.py 파일은 자식 클래스 파일(모듈)
from microbit import button_a, button_b, display, Image
from base_features import DisplayObject, ButtonHandler

class InteractiveDisplay(DisplayObject):
    def show(self):
        """상속을 통해 DisplayObject의 show 메소드를 오버라이드합니다."""
        display.show(Image.CONFUSED)

class ButtonAHandler(ButtonHandler):
    def __init__(self):
        super().__init__(button_a)

class ButtonBHandler(ButtonHandler):
    def __init__(self):
        super().__init__(button_b)
```
* 샘플코드_02-main.py 파일
```
# main.py 파일은 상속된 클래스를 사용하는 파일
from custom_display import CustomDisplay
from microbit import sleep

# CustomDisplay 클래스의 인스턴스 생성
custom_display = CustomDisplay()

# 상속받은 메소드 호출
custom_display.show_image()  # BaseDisplay에서 상속받은 메소드
sleep(2000)

# 확장된 클래스에서 정의된 새로운 메소드 호출
custom_display.show_custom_image()
sleep(2000)
```

### 라이브 러리 이해 및 실습: random 라이브러리
* 샘플코드_03
```
from microbit import *
import random

def display_random_int():
    num = random.randint(1, 9)
    display.show(str(num))

def display_random_range():
    num = random.randrange(0, 10, 2)  # 0에서 9 사이의 짝수
    display.show(str(num))

def display_random_float():
    num = random.random()
    display.scroll(str(round(num, 2)))

def display_random_choice():
    items = ['A', 'B', 'C', 'D', 'E']
    choice = random.choice(items)
    display.show(choice)

def display_random_uniform():
    num = random.uniform(1, 3)
    display.scroll(str(round(num, 2)))

random_functions = [
    display_random_int,
    display_random_range,
    display_random_float,
    display_random_choice,
    display_random_uniform
]

current_function_index = 0

while True:
    if button_a.was_pressed():
        random_functions[current_function_index]()
        current_function_index = (current_function_index + 1) % len(random_functions)
        sleep(1000)
```

## 이해하기 샘플코드
* 샘플코드_01
  - '상속'을 사용하는 확장된 클래스
```
from microbit import *

class LED:
    def __init__(self, interval):
        self.interval = interval

    def blink(self):
        display.show(Image.HEART)
        sleep(self.interval)
        display.clear()
        sleep(self.interval)

class FancyLED(LED): # LED 클래스 상속
    def fancy_blink(self):
        for _ in range(2):
            self.blink()
        sleep(1000)
        for _ in range(3):
            self.blink()

# 클래스 사용
fancy_led = FancyLED(200) # 200ms 간격으로 점멸
while True:
    fancy_led.fancy_blink()
```

* 샘플코드_02- sensor_base.py 파일
  - 센서(온도, 조도, 마이크) 컨트롤 모듈화 코드 
  - 센서 기본 클래스 정의
```
# sensor_base.py
class SensorBase:
    def read(self):
        pass

    def display_value(self, value):
        print("Sensor value:", value)
```
* 샘플코드_02- sensor_readings.py 파일
  - 센서(온도, 조도, 마이크) 컨트롤 모듈화 코드
  - 특정 센서(온도, 조도, 마이크)를 위한 클래스 정의
```
# sensor_readings.py
from sensor_base import SensorBase
from microbit import accelerometer, temperature

class AccelerometerSensor(SensorBase):
    def read(self):
        x, y, z = accelerometer.get_values()
        return (x, y, z)

class TemperatureSensor(SensorBase):
    def read(self):
        return temperature()
```
* 샘플코드_02- main.py 파일
  - 센서(온도, 조도, 마이크) 컨트롤 모듈화 코드
  - 센서 클래스 사용
```
# main.py
from sensor_readings import AccelerometerSensor, TemperatureSensor
from microbit import sleep

accelerometer_sensor = AccelerometerSensor()
temperature_sensor = TemperatureSensor()

while True:
    # 가속도 센서에서 x, y, z 축 값 읽기
    accel_values = accelerometer_sensor.read()
    print("Accelerometer values: x={0}, y={1}, z={2}".format(*accel_values))
    
    # 온도 센서 값 읽기
    temp_value = temperature_sensor.read()
    print("Temperature:", temp_value, "degrees Celsius")
    
    sleep(2000)
```

* 샘플코드_03- game_rules.py 파일
  - 0-100 까지 랜덤으로 생성된 숫자 빨리 맞추기 게임기
```
# game_rules.py
import random

def start_game():
    print(' 게임 조건:컴퓨터가 0부터 100까지 마음대로 생각한 숫자를 맞혀 보는 게임이에요.\n 숫자를 맞히기 위해 여러 번 추측할 수 있어요. 몇 번만에 맞혔는지 컴퓨터가 알려줄 거예요.\n 친구들과 게임을 하면서 누가 가장 적은 횟수로 숫자를 맞혔는지 확인해 보세요.\n 숫자를 가장 적게 말하고 맞힌 친구가 이기는 게임이랍니다.')
    return random.randint(0, 100)  # 0에서 100 사이의 난수 생성
```

* 샘플코드_03- number_guessing.py 파
  - 0-100 까지 랜덤으로 생성된 숫자 빨리 맞추기 게임기
```
# number_guessing.py
def guess_number(target):
    attempts = 0
    while True:
        try:
            guess = int(input("0-100 사이의 숫자를 입력하세요: "))
            attempts += 1
            if guess < 0 or guess > 100:
                print("0에서 100 사이의 숫자를 입력해야 합니다.")
            elif guess == target:
                print("축하합니다! 당신이 맞췄습니다.")
                return attempts
            else:
                if guess < target:
                    print("틀렸습니다. 입력한 값보다 큽니다. 다시 입력하세요.")
                else:
                    print("틀렸습니다. 입력한 값보다 작습니다. 다시 입력하세요.")
        except ValueError:
            print("정수를 입력해야 합니다.")
```

* 샘플코드_03- main.py 파일
  - 0-100 까지 랜덤으로 생성된 숫자 빨리 맞추기 게임기
```
from microbit import*
from game_rules import start_game
from number_guessing import guess_number
import music


def main():
    target_number = start_game()  # 게임 시작 및 난수 생성
    attempts = guess_number(target_number)  # 사용자로부터 숫자 입력 받고, 시도 횟수 반환
    print('총 {}번 시도하여 숫자를 맞히셨습니다.'.format(attempts))
    display.scroll(attempts)
    sleep(4000)
    music.play(music.PYTHON)
    

if __name__ == '__main__': #main()으로 실행해도 무방
    main()
```

## 적용하기 샘플코드
* 샘플코드_01
  - GPT프롬프트 템플릿
    ```
  
    ```
  - GPT 프롬프트 템플릿 입력 내용
    ```
   
    ```
  - GPT생성 코드
    ```
   
    ```
