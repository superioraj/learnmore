# 복합자료형(list) 파트 코드
## 배우기 샘플코드
### 리스트 만들기 및 자주 활용하는 표현
* 샘플코드_01-1
```
from microbit import * 

blank = []
numbers = ['one', 'two', 'three', 'four', 'five']
print(blank)
print(numbers) #display.show(), display.scroll()은 전체 리스트 값을 인자로 받지 못함.

# display.scroll(numbers) ->오류
# display.show(numbers) ->오류

#str()로 캐스팅 하면 출력은 가능하지만 list안의 []까지 하나의 문자로 출력되는 형태임.
display.scroll(str(numbers), delay=70)
display.show(str(numbers))
```
* 샘플코드_01-2
```
from microbit import * 

numbers = ['one', 'two', 'three', 'four', 'five']
for number in numbers:
    print(number)
    display.scroll(number)
```

* 샘플코드_01-3
```
from microbit import * 

numbers = [1, 2, 3, 4, 5]
for i in numbers:
    print(i)
    sleep(500)
    display.show(i)
    sleep(500)
```

* 샘플코드_01-4
```
#random 라이브러리 이해

from microbit import *
import random

hands = ['rock', 'paper', 'scissors']
print(random.choice(hands)) #random.choice()가 호출될 때마다 리스트에서 다른 값을 가지고 온다.
display.scroll(random.choice(hands), delay=40)
```

* 샘플코드_01-5
```
#리스트 인덱싱

from microbit import *
import random

hands = ['rock', 'paper', 'scissors']
print(hands[0])
display.scroll(hands[0], delay=40)
```

* 샘플코드_01-6
```
#리스트 슬라이싱
from microbit import *

numbers = [1,2,3,4,5,6,7,8,9,10]
print(numbers[0:3])#이 표현을 자주 사용
print(numbers[0:11:2])
print(numbers[10:0:-1])

display.scroll(str(numbers[0:3]), delay=40)
display.scroll(str(numbers[0:11:2]), delay=40)
display.scroll(str(numbers[10:0:-1]), delay=40)
```

### 리스트 용용 및 함수
* 샘플코드_02-1
```
from microbit import *

alpahbet = ['a', 'b', 'd', 'd', 'e']
alpahbet[2] = 'c' #리스트는 값을 교체 할 수 있음. 정수, 실수, 리스트 모두 가능.
print(alpahbet)
display.scroll(str(alpahbet))
```
* 샘플코드_02-2
```
# 리스트 데이터 스왑_str
from microbit import *

alphabet = ['a', 'b', 'd', 'd', 'e']
alpahabet[2] = 'c' #리스트는 값을 교체 할 수 있음. 정수, 실수, 리스트 모두 가능.
print(alpahbet)
display.scroll(str(alpahbet))
```

* 샘플코드_02-3
```
# 리스트 데이터 스왑_int
from microbit import *

alphabet = ['a', 'b', 'd', 'd', 'e']
for i in range(5):
    alphabet[i] = i  #마이크로 비트 에디터 창에서 오류가 발생함. 오류 이유는 리스트 값이 문자인데 정수를 넣으려해서 오류 발생. 리스트는 정수로 데이터 데이터 스왑이 가능하기에 오류 무시하고 실행됨. 
num_list = alphabet
print(num_list)
display.show(str(num_list))
```

* 샘플코드_02-4
```
# 리스트 데이터 스왑_list
from microbit import *

num_list = [1, 2, 3, 4, 5]
for i in range(3):
    num_list[i] = [0]
print(num_list)

num_list[0][0] = 3.14
num_list[1][0] = 'a', 'b', 'c'

print(num_list)
display.scroll(str(num_list[0][0]))
```

* 샘플코드_02-5
```
# 리스트 함수 한번에 끝내기
from microbit import *

#과일가게 진열대
fruit_list = ['apple', 'banana', 'strawberry', 'orange']

#어느날 mango과일이 들어와서 진열대 제일 뒤에 추가하려면?
fruit_list.append('mango')
print(fruit_list)

#리스트 인덱싱으로 4번 주소에 망고 들어온 것을 확인
display.scroll(fruit_list[4], delay=35)

#오렌지가 떨어져서 lemon으로 교체하려면?
fruit_list[3] = 'lemon'
display.scroll(fruit_list[3], delay=35) #3번주소 데이터 스왑으로 교체

#새로운 과일 grape이 들어와서 2번 주소에 추가하려면?
fruit_list.insert(2, 'grape') #2번 주소에 grape 삽입되고, 다른 과일은 뒤로 밀림
print(fruit_list)

#apple이 다 팔려서 진열대에서 없애려면?
fruit_list.pop(0) #리스트 주소값으로 제거
print(fruit_list)
display.scroll(fruit_list[0], delay=35) #0번 주소 과일이 banana로 변경됨을 확인

#진열대 순서(주소값)을 모르는데 strawberry가 모두 떨어저셔 없어애려면?
fruit_list.remove('strawberry')
print(fruit_list)

#이제 남은 과일 수를 확인하려면?
display.scroll(len(fruit_list))

#진열대 과일이 모두 다 팔려서 모두 삭제하려면?
fruit_list.clear()
print(fruit_list)
display.scroll(str(fruit_list))
sleep(1000)
```


### 리스트 정렬과 카운트 함수
* 샘플코드_03-1
```
#리스트 정렬, 역순 정렬
from microbit import*
import music

alphabet = ['p', 'b', 'w', 'j', 'm', 'f', 'i', 'x', 's', 'n', 't', 'y', 'q', 'c', 'l', 'v', 'z', 'd', 'e', 'r', 'h', 'k', 'u', 'a', 'o', 'g']
display.show(alphabet, delay=180)
music.play(music.BA_DING)


alphabet.sort() # 마이크로 비트 에디터에서는 데이터 타입 에러가 발생하지만, 코드에 오류가 없기에 잘 구동된다.
display.show(alphabet, delay=180)
music.play(music.BA_DING)

alphabet.reverse()
display.show(alphabet, delay=180)
music.play(music.BA_DING)
```

* 샘플코드_03-2
```
#리스트 카운트 함수
#리스트 정렬, 역순 정렬
from microbit import*

alphabet = ['p', 'b', 'a', 'w', 'j', 'b', 'm', 'f', 'i', 'x', 's', 'c', 'n', 't', 'y', 'q', 'c', 'l', 'v', 'z', 'd', 'e', 'a', 'r', 'h', 'k', 'u', 'a', 'o', 'g']
while True:
    search = str(input('알파벳을 입력해주세요:'))
    print('{}의 개수는 {}입니다'.format(search, alphabet.count(search)))
    display.show(alphabet.count(search))
```

* 샘플코드_03-3
```
#리스트 카운트 합수 응용
from microbit import*
import music

alphabet = ['p', 'b', 'a', 'w', 'j', 'b', 'm', 'f', 'i', 'x', 's', 'c', 'n', 't', 'y', 'q', 'c', 'l', 'v', 'z', 'd', 'e', 'a', 'r', 'h', 'k', 'u', 'a', 'o', 'g']

for x in range(len(alphabet)):
    print('{}주소의 알파벳은 개수는 {}입니다'.format(alphabet[x], alphabet.count(alphabet[x])))
    if alphabet.count(alphabet[x]) > 1:
        music.play(music.JUMP_UP)
        sleep(500)
#코드의 문제점은? 중복이 되는 단어가 나올 때 500ms마다 멈추며 JUMP_UP소리를 내준다. 자동으로 중복 단어를 검색하고 개수만 알려주도록 할 수는 없을까?
```


## 이해하기 샘플코드
* 샘플코드_01
  - 가위, 바위, 보 게임 장치 만들기(라디오 통신 활용)
  - 송신(Send) 코드
```
from microbit import *
import random
import radio

# 라디오 설정
radio.on()
radio.config(channel=7)
hand = ['scissors', 'rock', 'paper']

while True:
    if button_a.was_pressed():
        # 가위바위보 중 하나를 선택합니다.
        send_choice = random.randint(0,3)
        
        # 선택한 값을 라디오로 전송합니다.
        radio.send(str(send_choice))
        
        # 결과를 디스플레이에 출력합니다.
        if choice == 0:
            print(hand[send_choice])
            display.show(Image('00000:'
                               '08080:'
                               '00800:'
                               '08880:'
                               '08880'))
            sleep(1000)
            
        elif choice == 1:
            print(hand[send_choice])
            display.show(Image('00000:'
                               '00000:'
                               '04440:'
                               '08880:'
                               '08880'))
            sleep(1000)
        elif choice == 2:
            print(hand[send_choice])
            display.show(Image('00000:'
                               '80808:'
                               '08880:'
                               '68886:'
                               '08880'))
            sleep(1000)
        sleep(1000)
        display.clear()
```

  - 수신(Recieve) 코드
```
from microbit import *
import radio
import random

# 라디오 설정
radio.on()
radio.config(channel=7)

while True:
    display.scroll("Press A to play...")
    radio.receive()
    
    if button_a.was_pressed():
        # 상대방의 선택을 받아옵니다.
        opponent_choice = radio.receive()
        
        if opponent_choice is not None:
            opponent_choice = int(opponent_choice)
            
            # 자신의 선택을 랜덤으로 생성합니다.
            my_choice = random.randint(0, 2)
            
            # 결과를 판단합니다.
            result = (my_choice - opponent_choice) % 3
            
            if result == 0:
                display.show("DRAW")
            elif result == 1:
                display.show("WIN")
            else:
                display.show("LOSE")
            
            sleep(2000)
            display.clear()
```

* 샘플코드_02
  - 버튼으로 리스트 값 LED 출력하기
```
from microbit import *

# 리스트와 초기 인덱스
my_list = ['a', 'b', 'c', 'd', 'e', 'f']
index = 0

while True:
    # A 버튼을 누르면 인덱스 증가
    if button_a.was_pressed():
        index -= 1
        if index < 0:
            index = len(my_list) - 1
        

    # B 버튼을 누르면 인덱스 감소
    if button_b.was_pressed():
        index += 1
        if index >= len(my_list):
            index = 0

    # 현재 선택된 값을 LED에 표시
    display.show(my_list[index])
```

* 샘플코드_03
 - 중복된 리스트 값만 찾아내는 코드
```
#리스트 카운트 합수 응용
alphabet = ['p', 'b', 'a', 'w', 'j', 'b', 'm', 'f', 'i', 'x', 's', 'c', 'n', 't', 'y', 'q', 'c', 'l', 'v', 'z', 'd', 'e', 'a', 'r', 'h', 'k', 'u', 'a', 'o', 'g']
overlap = {}  # 중복된 알파벳을 저장하기 위한 빈 딕셔너리

for x in alphabet:
    count = alphabet.count(x)
    if count > 1:
        overlap[x] = count

for letter, count in overlap.items():
    print('{} 주소의 알파벳은 개수는 {}입니다'.format(letter, count))
```

## 적용하기 샘플코드
* 샘플코드_01
  - GPT프롬프트 템플릿
    ```
  
    ```
  - GPT 프롬프트 템플릿 입력 내용
    ```
   
    ```
  - GPT생성 코드
    ```
   
    ```
